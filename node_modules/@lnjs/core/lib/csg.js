"use strict";
exports.__esModule = true;
var shape_1 = require("./shape");
var ray_1 = require("./ray");
var Paths = require("./paths");
var CSGOperation;
(function (CSGOperation) {
    CSGOperation[CSGOperation["Intersection"] = 0] = "Intersection";
    CSGOperation[CSGOperation["Difference"] = 1] = "Difference";
    CSGOperation[CSGOperation["Union"] = 2] = "Union";
})(CSGOperation = exports.CSGOperation || (exports.CSGOperation = {}));
var BooleanShape = /** @class */ (function () {
    function BooleanShape(op, a, b) {
        this.op = op;
        this.a = a;
        this.b = b;
    }
    BooleanShape.create = function (op) {
        var shapes = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            shapes[_i - 1] = arguments[_i];
        }
        if (shapes.length === 0) {
            return new shape_1.EmptyShape();
        }
        var shape = shapes[0];
        for (var i = 1; i < shapes.length; i++) {
            shape = new BooleanShape(op, shape, shapes[i]);
        }
        return shape;
    };
    BooleanShape.prototype.compile = function () {
        // Noop
    };
    BooleanShape.prototype.boundingBox = function () {
        var a = this.a.boundingBox();
        var b = this.b.boundingBox();
        return a.extend(b);
    };
    BooleanShape.prototype.contains = function (v, f) {
        f = 1e-3;
        switch (this.op) {
            case CSGOperation.Intersection:
                return this.a.contains(v, f) && this.b.contains(v, f);
            case CSGOperation.Difference:
                return this.a.contains(v, f) && !this.b.contains(v, -f);
        }
        return false;
    };
    BooleanShape.prototype.intersect = function (r) {
        var h1 = this.a.intersect(r);
        var h2 = this.b.intersect(r);
        var h = h1.min(h2);
        var v = r.position(h.t);
        if (!h.ok() || this.contains(v, 0)) {
            return h;
        }
        return this.intersect(new ray_1["default"](r.position(h.t + 0.01), r.direction));
    };
    BooleanShape.prototype.paths = function () {
        var a = this.a.paths();
        var b = this.b.paths();
        var p = a.concat(b);
        return Paths.filterPaths(Paths.chop(p, 0.01), this);
    };
    BooleanShape.prototype.filter = function (v) {
        return [v, this.contains(v, 0)];
    };
    return BooleanShape;
}());
exports.BooleanShape = BooleanShape;
