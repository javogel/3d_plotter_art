"use strict";
exports.__esModule = true;
var box_1 = require("./box");
var tree_1 = require("./tree");
var vector_1 = require("./vector");
var cube_1 = require("./cube");
var matrix_1 = require("./matrix");
var plane_1 = require("./plane");
var set_1 = require("./set");
var Mesh = /** @class */ (function () {
    function Mesh(triangles) {
        var box = box_1.boxForShapes(triangles);
        this.box = box;
        this.triangles = triangles;
        this.tree = new tree_1.Tree(triangles);
        this.dirty = false;
    }
    Mesh.prototype.compile = function () {
        if (this.dirty) {
            this.tree = new tree_1.Tree(this.triangles);
            this.dirty = false;
        }
    };
    Mesh.prototype.boundingBox = function () {
        return this.box;
    };
    Mesh.prototype.contains = function (v, f) {
        return false;
    };
    Mesh.prototype.intersect = function (r) {
        var tree = this.tree;
        if (tree === null) {
            throw new Error("Intersecting null tree in Mesh");
        }
        return tree.intersect(r);
    };
    Mesh.prototype.paths = function () {
        var result = [];
        for (var _i = 0, _a = this.triangles; _i < _a.length; _i++) {
            var t = _a[_i];
            result.push.apply(result, t.paths());
        }
        return result;
    };
    Mesh.prototype.updateBoundingBox = function () {
        this.box = box_1.boxForShapes(this.triangles);
    };
    Mesh.prototype.unitCube = function () {
        this.fitInside(new box_1.Box(new vector_1["default"](0, 0, 0), new vector_1["default"](1, 1, 1)), new vector_1["default"](0, 0, 0));
        this.moveTo(new vector_1["default"](0, 0, 0), new vector_1["default"](0.5, 0.5, 0.5));
    };
    Mesh.prototype.moveTo = function (position, anchor) {
        var matrix = matrix_1.translate(position.sub(this.box.anchor(anchor)));
        this.transform(matrix);
    };
    Mesh.prototype.fitInside = function (box, anchor) {
        var scale = box
            .size()
            .div(this.boundingBox().size())
            .minComponent();
        var extra = box.size().sub(this.boundingBox()
            .size()
            .multiplyScalar(scale));
        var matrix = matrix_1.identity();
        matrix = matrix.translate(this.boundingBox().min.multiplyScalar(-1));
        matrix = matrix.scale(new vector_1["default"](scale, scale, scale));
        matrix = matrix.translate(box.min.add(extra.mul(anchor)));
        this.transform(matrix);
    };
    Mesh.prototype.transform = function (matrix) {
        for (var _i = 0, _a = this.triangles; _i < _a.length; _i++) {
            var t = _a[_i];
            t.v1 = matrix.mulPosition(t.v1);
            t.v2 = matrix.mulPosition(t.v2);
            t.v3 = matrix.mulPosition(t.v3);
            t.updateBoundingBox();
        }
        this.updateBoundingBox();
        this.dirty = true; // dirty
    };
    Mesh.prototype.saveBinarySTL = function (path) {
        // TODO
        return new Error();
    };
    Mesh.prototype.voxelize = function (size) {
        var z1 = this.box.min.z;
        var z2 = this.box.max.z;
        var set = new set_1.HashSet();
        for (var z = z1; z <= z2; z += size) {
            var plane = new plane_1["default"](new vector_1["default"](0, 0, z), new vector_1["default"](0, 0, 1));
            var paths = plane.intersectMesh(this);
            for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
                var path = paths_1[_i];
                for (var _a = 0, path_1 = path; _a < path_1.length; _a++) {
                    var v = path_1[_a];
                    var x = Math.floor(v.x / size + 0.5) * size;
                    var y = Math.floor(v.y / size + 0.5) * size;
                    var z_1 = Math.floor(v.z / size + 0.5) * size;
                    var vec = new vector_1["default"](x, y, z_1);
                    set.add(vec);
                }
            }
        }
        var result = [];
        set.forEach(function (v) {
            var cube = new cube_1["default"](v.subScalar(size / 2), v.addScalar(size / 2));
            result.push(cube);
        });
        return result;
    };
    return Mesh;
}());
exports["default"] = Mesh;
