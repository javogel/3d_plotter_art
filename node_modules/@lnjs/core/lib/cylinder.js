"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var box_1 = require("./box");
var vector_1 = require("./vector");
var hit_1 = require("./hit");
var math_1 = require("./math");
var Cylinder = /** @class */ (function () {
    function Cylinder(radius, z0, z1) {
        this.radius = radius;
        this.z0 = z0;
        this.z1 = z1;
    }
    Cylinder.prototype.compile = function () {
        // noop
    };
    Cylinder.prototype.boundingBox = function () {
        var r = this.radius;
        var min = new vector_1["default"](-r, -r, this.z0);
        var max = new vector_1["default"](r, r, this.z1);
        return new box_1.Box(min, max);
    };
    Cylinder.prototype.contains = function (v, f) {
        var xy = new vector_1["default"](v.x, v.y, 0);
        if (xy.length() > this.radius + f) {
            return false;
        }
        return v.z >= this.z0 - f && v.z <= this.z1 + f;
    };
    Cylinder.prototype.intersect = function (ray) {
        var _a;
        var r = this.radius;
        var o = ray.origin;
        var d = ray.direction;
        var a = d.x * d.x + d.y * d.y;
        var b = 2 * o.x * d.x + 2 * o.y * d.y;
        var c = o.x * o.x + o.y * o.y - r * r;
        var q = b * b - 4 * a * c;
        if (q < 0) {
            return hit_1.NoHit;
        }
        var s = Math.sqrt(q);
        var t0 = (-b + s) / (2 * a);
        var t1 = (-b - s) / (2 * a);
        if (t0 > t1) {
            _a = [t1, t0], t0 = _a[0], t1 = _a[1];
        }
        var z0 = o.z + t0 * d.z;
        var z1 = o.z + t1 * d.z;
        if (t0 > 1e-6 && this.z0 < z0 && z0 < this.z1) {
            return new hit_1["default"](this, t0);
        }
        if (t1 > 1e-6 && this.z0 < z1 && z1 < this.z1) {
            return new hit_1["default"](this, t1);
        }
        return hit_1.NoHit;
    };
    Cylinder.prototype.paths = function () {
        var result = [];
        for (var a = 0; a < 360; a += 10) {
            var x = this.radius * Math.cos(math_1.radians(a));
            var y = this.radius * Math.sin(math_1.radians(a));
            var p = [new vector_1["default"](x, y, this.z0), new vector_1["default"](x, y, this.z1)];
            result.push(p);
        }
        return result;
    };
    return Cylinder;
}());
exports.Cylinder = Cylinder;
var OutlineCylinder = /** @class */ (function (_super) {
    __extends(OutlineCylinder, _super);
    function OutlineCylinder(eye, up, radius, z0, z1) {
        var _this = _super.call(this, radius, z0, z1) || this;
        _this.eye = eye;
        _this.up = up;
        return _this;
    }
    OutlineCylinder.prototype.paths = function () {
        var center = new vector_1["default"](0, 0, this.z0);
        var hyp = center.sub(this.eye).length();
        var opp = this.radius;
        var theta = Math.asin(opp / hyp);
        var adj = opp / Math.tan(theta);
        var d = Math.cos(theta) * adj;
        var w = center.sub(this.eye).normalize();
        var u = w.cross(this.up).normalize();
        var c0 = this.eye.add(w.multiplyScalar(d));
        var a0 = c0.add(u.multiplyScalar(this.radius * 1.01));
        var b0 = c0.add(u.multiplyScalar(-this.radius * 1.01));
        center = new vector_1["default"](0, 0, this.z1);
        hyp = center.sub(this.eye).length();
        opp = this.radius;
        theta = Math.asin(opp / hyp);
        adj = opp / Math.tan(theta);
        d = Math.cos(theta) * adj;
        w = center.sub(this.eye).normalize();
        u = w.cross(this.up).normalize();
        var c1 = this.eye.add(w.multiplyScalar(d));
        var a1 = c1.add(u.multiplyScalar(this.radius * 1.01));
        var b1 = c1.add(u.multiplyScalar(-this.radius * 1.01));
        var p0 = [];
        var p1 = [];
        for (var a = 0; a < 360; a++) {
            var x = this.radius * Math.cos(math_1.radians(a));
            var y = this.radius * Math.sin(math_1.radians(a));
            p0.push(new vector_1["default"](x, y, this.z0));
            p1.push(new vector_1["default"](x, y, this.z1));
        }
        return [
            p0,
            p1,
            [new vector_1["default"](a0.x, a0.y, this.z0), new vector_1["default"](a1.x, a1.y, this.z1)],
            [new vector_1["default"](b0.x, b0.y, this.z0), new vector_1["default"](b1.x, b1.y, this.z1)]
        ];
    };
    return OutlineCylinder;
}(Cylinder));
exports.OutlineCylinder = OutlineCylinder;
// TODO NewTransformedOutlineCycliner
